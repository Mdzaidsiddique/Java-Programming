- Arrays are type safe & collections are not type safe
- Arrays are fixed in size

Type Casting:
- in case of array, at the tim eof retrieval type casting is not required coz arrays hold similar types of obj
- but in case of collections type casting is required coz it may holds distinct types of objects

Unbounded type:
- there are no restrictions, hence it is unbounded type
- class Type<T>{}, Test<Integer> t1 = new Test<Integer>();

Bounded types (extends kw):
- we can bound the parameter using extends kw, such types called bounded types
- we can't use `implements` & `super` but can replace `implements` kw purpose with `extends` kw
    : class Test<T extends Number> (valid)
    : class Test<T extends Runtime> (valid)
    : class Test<T implements Runtime> (invalid)
    : class Test<T super Runtime> (invalid)

class <T extends X>:
    - X can either class or interface
    - if X is class, then type parameter can either be X types or its child classes
    - if X is interface, then type parameter can either be X types or its implementation class

- Based on our requirements we can declare any number of Type Parameters
- and all these TypeParameter should be separated with commas
- Example Class HashMap<K,V>() | Class Test<X,Y,Z>()





