equals() and hashCode() methods in java:

    - both methods are defined in object class, that means these two methods are implicitly defined
      in every java class including custom classes
    - we can override these two methods inside our java class to make two objects logically equal
    - both method should be overridden to get complete equality mechanism (only equals is not sufficient)

equals():
    - from java.Object class, used to compare two objects (compare values of both object attributes)
    - by default, two objects are same only if stored in the same memory location
    - public boolean equals(Object obj) -> returns true if equal else false

general contract:
equal() methods must be: (while implementing equals method)
    1) reflexive: obj x must be equal to itself, -> equal(x) should return true
    2) symmetric: if x.equals(y) -> true, then y.equals(x) must be true
    3) transitive: if x.equals(y) -> true & y.equals(z) -> true, then x.equals(z) must be true
    4) consistent: result should be consistent
    5) x.equals(null): must be false

object class equals method definition:

    public boolean equals(Object obj){
        if(obj == null) return false;
        else return this == obj;
    }

--------------------------------------------------------------------------------------
hashCode() method:
    - it returns the hash code value (integer) of an object
    - if two objects are equal according to equals(), it returns same hashcode value else different
    * However, two objects having the same hashcode doesn't mean they are equal (hash collisions can happen)
    - syntax: public int hashCode()

general contract for hasCode() method:
    - if two obj x & y are equal acc to equals() then x.hasCode() == y.hasCode()
    - If two objects are not equal, they can have the same hashcode (collision possible)
      but better if they don’t (for performance)
    - The hashCode() must consistently return the same value during a single execution of the program
      unless the object’s fields used in equals() change.

Why is hashCode() important?
    - If you don’t override hashCode() when overriding equals(), in a HashSet or HashMap,
      objects that are equal may be treated as different because they land in different buckets

Hash collision:
- Why collisions happen:
  - In Java, hashCode() returns a 32-bit signed integer
  - That means there are only 2³² (~4.29 billion) possible hashcode values
  - but the number of possible objects is way bigger (infinite in theory)
  - So, mathematically, different objects must sometimes end up with the same hashcode -> collision

- How Java handles collisions in HashMap / HashSet:
  - when two objects land in the same bucket because of a collision:
    - HashMap puts them into a linked list (Java 7) or a balanced tree (Java 8+ if too many collisions occur)
    - then it uses the equals() method to check if they are really the same object
    - if equals() returns true → overwrite value
    - if equals() returns false → store both in the same bucket

* If too many collisions happen, HashMap performance can degrade from O(1) (ideal) to O(n) (worst case)

